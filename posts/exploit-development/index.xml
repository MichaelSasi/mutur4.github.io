<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Exploit Development on GILBERT ROBERT M</title>
        <link>https://mutur4.github.io/posts/exploit-development/</link>
        <description>Recent content in Exploit Development on GILBERT ROBERT M</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>sas</copyright>
        <lastBuildDate>Sun, 06 Mar 2022 20:41:56 +0300</lastBuildDate>
        <atom:link href="https://mutur4.github.io/posts/exploit-development/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Pwnkit (Local Priv Escalation)</title>
            <link>https://mutur4.github.io/posts/exploit-development/pwnkit/</link>
            <pubDate>Tue, 01 Feb 2022 22:36:46 +0300</pubDate>
            
            <guid>https://mutur4.github.io/posts/exploit-development/pwnkit/</guid>
            <description>CVE-2021-4034 (PWNKIT - Linux Privilege Escalation) This is a local linux privilege escalation in polkit&amp;rsquo;s pkexec that affects almost every linux distribution. That means that any user can become root when they exploit this vulnerability. Today we are going to look at the effects of OOB (out-of-bounds) read and write and how they can be critical.This was a vulnerablity that was discovered by the security company Qualys.
 Recap What is an OOB vulneraility?</description>
            <content type="html"><![CDATA[<h3 id="cve-2021-4034-pwnkit---linux-privilege-escalation">CVE-2021-4034 (PWNKIT - Linux Privilege Escalation)</h3>
<p>This is a local linux privilege escalation in polkit&rsquo;s pkexec that
affects almost every linux distribution. That means that any user can
become root when they exploit this vulnerability. Today we are going to
look at the effects of OOB (out-of-bounds) read and write and how they can
be critical.This was a vulnerablity that was discovered by the security company Qualys.</p>
<hr>
<h3 id="recap">Recap</h3>
<p><strong><em>What is an OOB vulneraility?</em></strong></p>
<p>An out-of-bounds write <strong><em>(OOBW)</em></strong> vulnerability is when a process or a software
writes data past the end or before the beginning of the allocated buffer in memory.
An out-of-bounds read vulnerability <strong><em>(OOBR)</em></strong> is when a process reads data
from outside the bounds of an allocated buffer in memory.These vulnerabilities can therefore
lead to <em>memory corruption</em>, <em>a system crash</em> or <em>chained for RCE</em>.We are going to see in play the
effect of these vulnerabilities chained leading to a local privilege escalation.</p>
<p><strong><em>What is this polkit pkexec in linux?</em></strong></p>
<p>This is a tool from the <em>polkit</em> or <em>policy kit software package</em> and it
is a common component for modern unix-based systems. It is used to control
system-wide privileges and provides an organized way for non-privileged
processes to communicate with privileged processes. It can also be used to
execute commands with elevated privileges much like <em>sudo</em> using the command
<strong>pkexec</strong> command.</p>
<p><strong><em>According to the linux manual page</em></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>man polkit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PolicyKit provides an authorization API intended to be used by privileged 
</span></span><span style="display:flex;"><span>programs <span style="color:#f92672">(</span>“MECHANISMS”<span style="color:#f92672">)</span> offering service to unprivileged programs <span style="color:#f92672">(</span>“CLIENTS”<span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span>through some form of IPC mechanism such as D-Bus or Unix pipes.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>man pkexec
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pkexec allows an authorized user to execute a PROGRAM as another user and 
</span></span><span style="display:flex;"><span>If that username is not specified, <span style="color:#66d9ef">then</span> the program will be executed as 
</span></span><span style="display:flex;"><span>the admin super user that is root.
</span></span></code></pre></div><h3 id="vulnerability">Vulnerability</h3>
<p>As started earlier the vulnerability is an out-of-bounds read and write
vulnerability and this can be seen from the source code snippet of pkexec
that was presented by <a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">Qualys Security Company</a>
during their disclosure.</p>
<p>Below are source code snippets that are used to describe the vulnerability in detail.</p>
<ol>
<li>The <em><strong>main()</strong></em> entry function that processes the command-line arguments.
<em><strong>(pkexec takes in different arguments from the command-line)</strong></em></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
</span></span><span style="display:flex;"><span>	....
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(n<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, n <span style="color:#f92672">&lt;</span> (guint) argc, n<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	path <span style="color:#f92672">=</span> g_strdup(argv[n]);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (path[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;/&#34;</span>){
</span></span><span style="display:flex;"><span>		s <span style="color:#f92672">=</span> g_find_program_in_path(path);
</span></span><span style="display:flex;"><span>		argv[n] <span style="color:#f92672">=</span> path <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>From the above snippet and as it is in every C application, the number
of arguments are stored in <code>argc</code> variable and the actual arguments passed stored in the pointer
array <code>char *argv[]</code>. Therefore when we pass no arguments to the <code>/usr/bin/pkexec</code> the value
of <code>argc</code> will be <code>1</code> <em><strong>(this is the calling process&rsquo;s name)</strong></em> which is also the value in <strong>argv</strong> followed by a <strong>null</strong> value to terminate the array.</p>
</li>
<li>
<p>This doesn&rsquo;t make sense at all we need <code>argv</code> to be NULL:(, its still not vulnerable to OOB, well remember we can
initiate any process with the <code>execve()</code> syscall and control args passed to the process. What if we pass a
<code>NULL</code> value to to <code>execve()</code> as follows:</p>
<p><code>execve(/usr/bin/pkexec, NULL, char **envp)</code></p>
</li>
</ul>
<blockquote>
<p>The value of <code>argc</code> will now be <code>0</code> and the value of <code>char *argv[]</code> will be <code>NULL</code>, terminating
the array.</p>
</blockquote>
<ul>
<li>
<p>As from the code snippet above, the following will be our values during execution.</p>
<ol>
<li><em>The <code>for</code> loop initializes <code>int n</code> to <code>1</code>.</em></li>
<li><em>The pointer <code>path</code> points to a <code>malloced()</code> address that is <code>argv[n]</code>, since the
value of n == 1, argv[1] reads passsed our terminated array leading to an OOBR.</em></li>
<li><em>The pointer <code>(s)</code> writes into <code>argv[1]</code> again and this leads
to an OOB-write vulnerability.</em></li>
</ol>
</li>
<li>
<p><strong>Since we did not provide any arguments when calling the process, what is
read and written into these pointers?.</strong> When a new process is called
with the <code>execve()</code> syscall or when you run a new process from the
terminal with command-line arguments, the kernel copies out arguments
and all eviroment variable strings and pointers to the end of the new
programs stack. That is to the end of the <code>main()</code> function stack.</p>
</li>
<li>
<p>Therefore <code>argv</code> and <code>envp</code> pointers are contagious in memory in that they
are next to each other as shown in the image below.</p>
</li>
</ul>
<p><img src="https://www.whitesourcesoftware.com/wp-content/media/2022/01/Screen-Shot-2022-01-27-at-7.59.19-1024x131.png" alt="image"></p>
<ul>
<li>
<p>This means that when we pass no arguments to <code>pkexec</code>, <code>argv[1]</code> now points to
out first enviroment variable that is set. Let us assume the following
scenarion:</p>
<ol>
<li><em>We add an environment variable called <em><strong>FOO</strong></em> by passing it to <code>execve()</code>.</em></li>
<li><em>When calling <code>pkexec</code> with not command-line arguments as above, the code snippet
will allocate <code>argv[1]</code> that is now <em><strong>FOO</strong></em> dynamically
on the heap using <code>g_strdup()</code> and the address returned to the <code>(path)</code> pointer.</em></li>
<li><em>It will then check if <code>path[0]</code> begins with <code>/</code> to determine if its an absolute path or not
which in this case it doesn&rsquo;t .</em></li>
<li><em>Since <em><strong>FOO</strong></em> does not contain <code>/</code> it will execute <code>g_find_program_in_path()</code>
and the value returned to <code>s</code> will the absolute path of <code>value</code> and this will
overwrite <code>argv[1]</code> which is now <code>envp[0]</code> (our environment variable) OOBW.</em></li>
</ol>
</li>
</ul>
<h2 id="exploitation">Exploitation</h2>
<p>How can this be exploited to gain root? According to the <strong>Qualys Security team</strong>,
Since we control <strong>envp[0]</strong>, that is an environment variable using the OOBW
vulnerability, we can write anything to <code>argv[1]</code> <em>(i.e envp[0])</em>. Therefore we need to
look at some of the dangerous enviroment variables that we can exploit.</p>
<p><em><strong>(Note that after the out-of-bounds write above, the process clears out its enviroment
variables.)</strong></em></p>
<p><strong>LD_PRELOAD</strong></p>
<p>This is an enviroment variable that specifies the first shared library to load. We can
therefore use the OOB-write to write this into our env variables but unfortuanetly,
(ld.so) clears these types of variables out when running suid processes and
before calling the main() function during execution.</p>
<p><strong>GCONV_PATH</strong></p>
<p>This is an enviroment variable somewhat similar to <em>LD_LIBARY_PATH</em> in functionality
and this is part of GLib that is the GNOME Library. GLib is a library that is build
on top of the C standard library and provides functions like error logging,authentication
and PATH lookups.</p>
<p>Since certain functions return messages to users, encoding
and decoding to and fro different formats must be considered and this
is where GCONV_PATH comes into play.</p>
<blockquote>
<p>When a process encounters e.g &ldquo;CHARSET=UTF-8&rdquo; enviroment variable, GLib
loads $GCONV_PATH/gconv-modules or when this variable is not set the lookup
is done from (&quot;/usr/lib/gconv/gconv-modules&quot;). This is a file that contains
something like &ldquo;BS_4730// UTF-8 ISO646 2&rdquo; and this is used to define a module located at
&ldquo;ISO646.so&rdquo; that will allow &ldquo;BS_4730&rdquo; to be re-encoded as &ldquo;UTF-8&rdquo;. (this is
just a simple example).</p>
</blockquote>
<blockquote>
<p>When we control the <code>GCONV_PATH</code>, we can therefore cause this
<code>SUID</code> process to run with full root privilleges by loading a shared library file that we
control in the <code>.so</code> file.</p>
</blockquote>
<h2 id="proof-of-concept">Proof Of Concept</h2>
<p>Below I have provided a snippet of my POC and the full code can
be found at my github page <a href="https://github.com/mutur4/Hacking-Scripts/tree/main/CVE-2021-4034">pwnkit.c</a>
there are also other different POC payloads out there with the same functionality so
be sure to check them out.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pkexec_envp[] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;tmp&#34;</span>, <span style="color:#e6db74">&#34;CHARSET=xxx&#34;</span>, <span style="color:#e6db74">&#34;PATH=GCONV_PATH=.&#34;</span>};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pkexec_args[] <span style="color:#f92672">=</span> {NULL};
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	mkdir(<span style="color:#e6db74">&#34;GCONV_PATH=.&#34;</span>, <span style="color:#ae81ff">0755</span>);
</span></span><span style="display:flex;"><span>	open(<span style="color:#e6db74">&#34;GCONV_PATH=./tmp&#34;</span>, O_CREAT, <span style="color:#ae81ff">0755</span>);
</span></span><span style="display:flex;"><span>	mkdir(<span style="color:#e6db74">&#34;tmp&#34;</span>, <span style="color:#ae81ff">07555</span>);
</span></span><span style="display:flex;"><span>	open(<span style="color:#e6db74">&#34;tmp/gconv-modules&#34;</span>, O_WRONLY, <span style="color:#ae81ff">0755</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	execve(<span style="color:#e6db74">&#34;/usr/bin/pkexec&#34;</span>, pkexec_args, pkexec_envp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>The above snippet works in the following way</strong></p>
<ol>
<li>
<p>Since we provided no arguments when calling <em><strong>pkexec</strong></em> via the <code>execve()</code> syscall,
<code>argv[1]</code> now becomes whatever we loaded in our enviroment variable that is <em><strong>tmp</strong></em>.</p>
</li>
<li>
<p>Since <em><strong>tmp</strong></em> does not start with <code>/</code>, the process will look for its absolute
path and will check from the paths provided by the <code>PATH</code> enviroment variable.</p>
</li>
<li>
<p>Since <em><strong>PATH</strong></em> variable contains our spoofed directory <code>GCONV_PATH=.</code> the
value that will be returned by <code>g_find_program_in_path()</code> will be <code>GCONV_PATH=./tmp</code>
as the absolute path.</p>
</li>
<li>
<p><code>GCONV_PATH=./tmp</code> is a valid environment variable therefore using the
oob-write we have an arbitrary write into <code>envp[0] = argv[1] = &quot;GCONV_PATH=./tmp&quot;</code>, since we also
included a <code>CHARSET=xxx</code> , GLib now comes into play and looks for <code>GCONV_PATH</code>
from the enviroment variables that contains <code>./tmp</code> as its value.</p>
</li>
<li>
<p>It will then go to out <code>./tmp</code> directory to look for <code>gconv-modules</code> and based on the contents, it will load a library from &ldquo;./tmp&rdquo; that we control and
when its loaded this will lead to our privilege escalation.</p>
</li>
<li>
<p>Basically the attack is based on the introduction of an insecure environment variable via the OOBW.</p>
</li>
</ol>
<h4 id="mitigations">Mitigations</h4>
<ol>
<li>Update pkexec to the latest version.</li>
<li>Remove the SUID bit in the executable.</li>
</ol>
<h4 id="references">References</h4>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://www.whitesourcesoftware.com/resources/blog/polkit-pkexec-vulnerability-cve-2021-4034/">https://www.whitesourcesoftware.com/resources/blog/polkit-pkexec-vulnerability-cve-2021-4034/</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://www.openwall.com/lists/oss-security/2022/01/25/11">https://www.openwall.com/lists/oss-security/2022/01/25/11</a></li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
